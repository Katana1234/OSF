------------- tasks to perform when publishing a new version ----------------
When changed are done to this firmware, I have to take care of:
- change some #define in main.h file:
    - #define VERSION "x.x.x"                                     This is the firmware version
    - #define _MAIN_CONFIGURATOR_VERSION 1        to another number; first digit must be changed if xls configurator format changed (e.g. using a reserve field)
    - #define _SUB_CONFIGURATOR_VERSION  1         to another value if minor change is done in xls configurator 
    - #define DEBUG_ON_JLINK         (0)                          to avoid debug messages via jlink
    - #define USE_CONFIG_FROM_COMPILATION (0)                     to force it to use the config flashed in the upper part of memory (generated with xls)
    - #define WHEEL_SPEED_X10_SIMULATE  (0)                       to avoid simulation of wheel speed sensor
    - #define DEFAULT_TEST_MODE_FLAG        NORMAL_RUNNING_MODE   to avoid that it run in test mode
- compile the firmware with menu Terminal + Run build task ; it creates a HEX and a ELF file in the build/last config folder.
- do a copy paste of the HEX file to the folder /OSF/files_to_flash 
- rename this paste as "OSF_TSDZ8_Vxx_xx_xx.hex" where XX_XX_XX is the same as the firmware version in main.h

- if there are change in java configurator, compile the java firmware and rename it in OSF_TSDZ8_configurator


------------  General infos --------------------
Normally there is no need to recompile this firmware with different parameters depending on the desired options.

It is possible to change the main configuration parameters with a configurator in xls and to just flash a small file with those parameters on top of the firmware.

So, a normal user does not have to install all the tools for compiling him self.

Still it can be usefull to install uc_probe to fine tune/monitor some parameters.
Use this link for dowloading it : https://infineoncommunity.com/uC-Probe-XMC-software-download_ID712


It seems that the hall sensors are not equaly spaced in TSDZ8 and some calibration could be useful.
In this version, the firmware try to find the relative positions of the different hall sensors.
It let the motor runs and when the speed is high enough and stable, it compared the
- theoretical position of each sensor (based on the enlapsed time)
- with the position store in a reference table.
Applying some smoothing filter, it adjusts automatically the reference table of the hall sensors.
This is done taking the hall pattern 1 as reference and adjusting the position for the others.

Still, at this stage, position of hall pattern 1 is perhaps not the best one.

To find the best position for hall patterns 1, it is possible to change a little a global offset and to see which one provides the lowest current (for a given duty cycle).
This can be done using Jlink and another firmware (uc_probe) on the PC.
This is further explain in the Readme section.



***********  doc about use of posif ******************

- when a change occurs on hall sensor, posif.out sent a signal to ccu4 slice 0 Input0
- this rising edge activates the function clear & start timer on CCU4 slice 0
- when ccu4 timer reaches compare register, ccu4 ST changes (go high)
- this changes is received by posif on dsel 
- rising edge of dsel on posif generates a sample of hall pins
- if the sample == current , nothing happens
- if sample == expected,
    - in posif : shadow registers (current and expected patterns) are copied in active registers
    - in posif: shadow registers becomes 0 0 (and must be reloaded)
    - in posif a service request 0 is generated; it can be handled by POSIT0_1_IRQ to upload new value in shadow reg
     (in fact, this could also be done by the interrupt generated by ccu4 slice 1 on compare match)
    - in posif : posif set OUT1 high and this signal is connected to CCU4 slice 1 input 0
    - in CCU4 slice 1 = this input signal activates an envent 0 that generates
            - a function "capture" of the current value of the timer (this value can be read to know the interval)
            - a clear & start of the timer
            - a service request 0 that can be used e.g. in an interrupt CCU4_0_0_IRQ to get the capured value
                note: reading the value, reset a flag ; this allows to know if it is a new value or nothing
        note: when timer count up to 0XFFFF but it can be changed (with prescaler = 256, 1 tick = 4 usec, so max = 65536 *4 = 0,262 sec)
        with 6 phases per electrical rotation and 4 poles, this is equivalent to a rps of 0,15 = about 10 rpm
        This could generate an CCU4 SR1 but it is not yet done because at power with 15Â° per 0,5 sec the limit is reached.
- if sample is not the expected, it is possible just to discard or to stop some process. Anyway OUT3 is set
    if IDLE is activated in the setup, a wrong pattern can generate an OU2 that can be used to stop the PWM
    currently in case of wrong pattern, there are no action generated by POSIF
notes : when slice 1 count up to the end of the period, ccu4 generates a service request 1 to say that motor is running slow
This SR1 could be manage to stop the motor state by an ISR

Still, in this version, we do not use posif to check for the validy of transition nor to measure the enlapsed time between 2 transitions
Posif detects only hall pattern change (valid or not) and trigger CCU4 slice 0.
This CCU4 slice 0 generates after a small delay an IRQ to capture the hall pattern and the value of a running timer CCU4 slice 2 (250Khz = 4usec per tick)

-------- doc about use of vadc and ccu8
ccu8 slice 0,1,2 are used to generate PWM . 
They are configured as center align, with prescaler = 1 (to get 64Mz ; this is 4X the freq of TSDZ2)
Period is 1680 (4*420) (so one cycle is 3360 clocks and so one tick every 15,625 nsec, => 19Khz => 26us per cycle = tSDZ2)
In original TSDZ8 firmware, there is a delay in CCU8 PWM (to avoid shortcut in the inverter. It is set on 1.09 usec ; I used a value of 1.5usec for more safety.
CC8 slice 3 is used to generate 2 IRQ : one when counting up at 840 (4*210) (SR0), and the other (SR1) at 840 counting down
CC8 slice 3 generates also a SR3 at period match and a SR2 at one match;
Those are connected to:
- VADC group 0 to trigger the queue and so measure total current (pin 2.8)
- VADC group 1 to trigger the queue and so measure total current (pin 2.8)
NOte:  the connection of SR2 can't be done within device manager because this tool accept only one connection between CCU8 and VADC
So set up of this connection is done in main.c

The 2 queues are used to measure also other voltages (battery, throttle, torque)
I do not know if it is right to measure total current at period match and at one match because all 3 mosfets are ON (on low side in one case and high side in the other one).
Currently, program uses the sum of the 2 groups.
Anyway, there seems to be quite big variations in ADC conversion for current.

In device configurator, it is possible to setup a channel event (per channel) when the ADC value is e.g. out of limits.
Still, it seems that it is not possible to let the channel event generates a service request.
It is then required to use 
VADC_GROUP_ChannelSetEventInterruptNode	(	XMC_VADC_GROUP_t *const 	group_ptr,const uint32_t 	ch_num,const XMC_VADC_SR_t 	sr )
And also it is required to add the 2 lines of code for NIVC to get the interrupt

Note:  per group only SR0 and SR1 can be connected to NIVC (17,18 for group 0 and 19,20 for group 1)


------------- CCU4 ----------------
- slice 0 is used to add a delay for sampling the hall sensors when a change occurs
- slice 1 was foreseen to measure the time between 2 patterns (if valid); in fact it is not required anymore and could be disabled.
- slice 2 is used as running counter to measure the delay between pattern change (and current irq0 from ccu8 when timer is running up)
- slice 3 is used to generate the PWM signal for torque (a pulse of 2,5us every 20 usec)

---------  vadc ------
A test with a battery with 37V gives a adc = 1720. This supposes a voltage on XMC pin of 1720 * 5V / 4096 steps = 2,099V
    Doc for tsdz2 says that a battery of 34,6V gives 1,99V on the xmc pin
    The 2 ratios are the sample
    So - BATTERY_VOLTAGE_PER_10_BIT_ADC_STEP_X1000 should be the same (if TSDZ8 ADC is reduced to 10 bits)

Note : when the controller is powered by the Jlink , the conversions does not seems ok.
Perhaps there is an issue with the calibration when VCC change?

Note : for current measurements, vADC is configured to use IIR filter; so result values (in register 15) are in 14 bits instead of 12

--------  note about bike display -------
The data being transmitted (for field Km/h on display) are in fact inverted (1/value)
The max value transmitted that is displayed is 1000 and gives 3,7km/h on the display
Transmitting 500 gives 7,4 kmh/h on the display.
Lowest values to transmit are probably around 60 (so a little more than 65 km/h)
But the values being transmitted depends on the selected diameter of the wheel.
This diameter is transmitted by the display to the controller and the controller takes it into accout to calculate the value to transmit

By default, the numerator used for conversion = 37310 (for wheel = ???)

So, it is not possible to view on the display current that are less than 3,7 A (display gives then 0)

------------- developper : to display messages from controller e.g. when debugging  -----------------
When the controller is powered on and the Jlink device is connected to the PC, you have to start the program J-link RTT viewer.
This software is delivered with all segger programs.
Once started, select the options:
- connect via USB
- specify as target XMC1303-0064
- target interface swd
- speed 4000 khz

The debug messages (if any) should then be displayed.

At each power on of the controller, it could be that you have to close and reopen jlink-RTT viewer.

Note : uc_probe is another and even easier tool because it allows to monitor data without having to change the firmware and without reflash.


------------- note using segger rtt for developper --------------
Here a link that explains the way Jlink can be used instead of uart to get debug message and/or send commands
https://kb.segger.com/RTT#SEGGER_RTT_printf()
It requires adding:
    - SEGGER_RTT_Init ();     
    - SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_TRIM);
Then it is possible to uses code like
    SEGGER_RTT_WriteString(0, RTT_CTRL_CLEAR); // clear the RTT terminal
    or
    SEGGER_RTT_printf(0, "Retry CCU8 start; still %u try\r\n", retry_counter);

    For printf, the syntax is            
    %[flags][FieldWidth][.Precision]ConversionSpecifier
    where flags can be
        -	= Left justify within the field width
        +	= Always print sign extension for signed conversions
        0	= Pad with 0 instead of spaces. Ignored when using '-'-flag or precision
    where conversion speecifier is
        c one char
        d signed integer
        u unsigned integer
        x hexadecimal integer
        s string
        p   8-digit hexadecimal integer. (Argument shall be a pointer to void.)

