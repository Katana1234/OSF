
// AVERAGING

// #define TORQUE_BUFFER_SIZE 20

// Only needed if not already defined in your environment
// typedef unsigned short uint16_t;
// typedef unsigned long  uint32_t;
// typedef unsigned int   size_t;

// static uint16_t torqueBuffer[TORQUE_BUFFER_SIZE];
// static size_t torqueBuffer_index = 0;
// static size_t torqueBuffer_count = 0;

// // void resetTorqueBuffer() {
// //     for (size_t i = 0; i < TORQUE_BUFFER_SIZE; ++i) {
// //         torqueBuffer[i] = 0;
// //     }
// //     torqueBuffer_index = 0;
// //     torqueBuffer_count = 0;
// // }

// void addToTorqueBuffer(uint16_t value) {
//     torqueBuffer[torqueBuffer_index] = value;
//     torqueBuffer_index = (torqueBuffer_index + 1) % TORQUE_BUFFER_SIZE;
//     if (torqueBuffer_count < TORQUE_BUFFER_SIZE) {
//         torqueBuffer_count++;
//     }
// }

// uint16_t getAverageTorque() {
//     if (torqueBuffer_count == 0) return 0;

//     uint32_t sum = 0;
//     for (size_t i = 0; i < torqueBuffer_count; ++i) {
//         sum += torqueBuffer[i];
//     }
//     return (uint16_t)(sum / torqueBuffer_count);
// }
// AVERAGING




// get adc pedal torque
		// by default we use ui16_adc_torque_filtered (calculated in motor.c irq)
		// when cadence is high enough, we use the max between actual value, actual rotation and previous rotation
		ui16_adc_pedal_torque = ui16_adc_torque_filtered;
		#define PEDAL_CADENCE_MIN_FOR_USING_ROTATION 30
		if (ui8_pedal_cadence_RPM > PEDAL_CADENCE_MIN_FOR_USING_ROTATION) { 
			if ( ui16_adc_pedal_torque < ui16_adc_torque_actual_rotation) ui16_adc_pedal_torque = ui16_adc_torque_actual_rotation ;
			if ( ui16_adc_pedal_torque < ui16_adc_torque_previous_rotation) ui16_adc_pedal_torque = ui16_adc_torque_previous_rotation ;
		} else {
			ui8_adc_torque_rotation_reset = 1 ; // will force also a reset of torque rotation in the motor.c irq 
		}

		// addToTorqueBuffer(ui16_adc_torque_filtered);
		// ui16_adc_pedal_torque = getAverageTorque();